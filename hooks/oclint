#!/usr/bin/env bash
# Wrapper script for oclint
################################################################################
CMD="oclint"
args=("$@")
get_script_dir () {
     SOURCE="${BASH_SOURCE[0]}"
     # While $SOURCE is a symlink, resolve it
     while [ -h "$SOURCE" ]; do
          DIR="$( cd -P "$( dirname "$SOURCE" )" > /dev/null && pwd )"
          SOURCE="$( readlink "$SOURCE" )"
          # If $SOURCE was a relative symlink (so no "/" as prefix, need to resolve it relative to the symlink base directory
          [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
     done
     DIR="$( cd -P "$( dirname "$SOURCE" )" > /dev/null && pwd )"
     echo "$DIR"
}
hook_dir="$(get_script_dir)"
. "$hook_dir/utils"

function get_oclint_ver {
	oclint --version | grep "OCLint version" | \
		awk '{print substr($3, 1, length($3)-1)}'
}

# Run OCLint and remove generated temporary files
function execute_cmd {
	pwd_files="$(ls)"
	# Split text into an array of args that can be passed into oclint
	output="$(oclint "${args[@]}" 2>&1)"
	# Remove any plist files generated by oclint
	echo "$pwd_files $(ls)" | tr ' ' '\n' | sort | uniq -u | grep .plist | xargs rm
}


# oclint return code is usually wrong (github.com/oclint/oclint/issues/538)
# Figure out what it is based on stdout and return that instead
function parse_output {
	no_errors="FilesWithViolations=0"
	if grep -q $no_errors <<<"$output"; then
		exit 0
	else
		# Following standard of printing to stdout ONLY if there are errors
		echo -e "${output}"
		exit 1
	fi
}


function oclint_main {
	check_installed "$CMD"
	parse_ddash_args "${args[*]}" "$(get_oclint_ver)"
	execute_cmd
	parse_output
}

oclint_main
